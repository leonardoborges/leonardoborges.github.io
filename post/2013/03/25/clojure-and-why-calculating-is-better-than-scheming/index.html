<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Leonardo Borges  | clojure and why calculating is better than scheming</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.67.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="clojure and why calculating is better than scheming" />
<meta property="og:description" content="Last week while attending Clojure/West in Portland I came across a paper called Why calculating is better than scheming. In a nutshell, this paper is a critique to Abelson and Sussman&lsquo;s classic textbook SICP - Structure and Interpretation of Computer Programs, used by MIT for many years to teach their introductory programming course.
If you haven&rsquo;t read SICP, you should. It&rsquo;s an amazing book. It uses Scheme, a dialect of Lisp, as the vehicle to present fundamental programming concepts." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://leonardoborges.com/post/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/" />
<meta property="article:published_time" content="2013-03-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2013-03-25T00:00:00+00:00" />
<meta itemprop="name" content="clojure and why calculating is better than scheming">
<meta itemprop="description" content="Last week while attending Clojure/West in Portland I came across a paper called Why calculating is better than scheming. In a nutshell, this paper is a critique to Abelson and Sussman&lsquo;s classic textbook SICP - Structure and Interpretation of Computer Programs, used by MIT for many years to teach their introductory programming course.
If you haven&rsquo;t read SICP, you should. It&rsquo;s an amazing book. It uses Scheme, a dialect of Lisp, as the vehicle to present fundamental programming concepts.">
<meta itemprop="datePublished" content="2013-03-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2013-03-25T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1663">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="clojure and why calculating is better than scheming"/>
<meta name="twitter:description" content="Last week while attending Clojure/West in Portland I came across a paper called Why calculating is better than scheming. In a nutshell, this paper is a critique to Abelson and Sussman&lsquo;s classic textbook SICP - Structure and Interpretation of Computer Programs, used by MIT for many years to teach their introductory programming course.
If you haven&rsquo;t read SICP, you should. It&rsquo;s an amazing book. It uses Scheme, a dialect of Lisp, as the vehicle to present fundamental programming concepts."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://leonardoborges.com/" class="f3 fw2 hover-white no-underline white-90 dib">
      Leonardo Borges
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=http://leonardoborges.com/post/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=http://leonardoborges.com/post/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/&amp;text=clojure%20and%20why%20calculating%20is%20better%20than%20scheming" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http://leonardoborges.com/post/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/&amp;title=clojure%20and%20why%20calculating%20is%20better%20than%20scheming" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">clojure and why calculating is better than scheming</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2013-03-25T00:00:00Z">March 25, 2013</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>Last week while attending <a href="http://clojurewest.org">Clojure/West</a> in Portland I came across a paper called <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf">Why calculating is better than scheming</a>. In a nutshell, this paper is a critique to <a href="http://en.wikipedia.org/wiki/Hal_Abelson">Abelson</a> and <a href="http://en.wikipedia.org/wiki/Gerald_Jay_Sussman">Sussman</a>&lsquo;s classic textbook <a href="http://mitpress.mit.edu/sicp/">SICP - Structure and Interpretation of Computer Programs</a>,
used by MIT for many years to teach their introductory programming course.</p>
<p>If you haven&rsquo;t read <a href="http://mitpress.mit.edu/sicp/">SICP</a>, you should. It&rsquo;s an amazing book. It uses <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, a dialect of Lisp, as the vehicle to present fundamental programming concepts.</p>
<p><a href="http://homepages.inf.ed.ac.uk/wadler/">Philip Wadler</a> - the author of this particular paper - contrasts teaching in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> to teaching using <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> and <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a>, pointing out
four major features he considers important and lacking in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>. They are:</p>
<ul>
<li>Pattern matching</li>
<li>A syntax close to traditional mathematical notation</li>
<li>A static type discipline and user-defined types</li>
<li>Lazy Evaluation</li>
</ul>
<blockquote>
<p>Note:  <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> influenced <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a> which in turn influenced <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>.  Their syntax is similiar, so where Wadler used Miranda code snippets in the paper, I&rsquo;ll be using Haskell in this post.</p>
</blockquote>
<p>As an aside, although the paper talks specifically of <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, the term Lisp is used quite loosely and could lead the not-so-careful reader to be misled regarding a whole family of languages. Lisps have come a long way and modern dialects - of which I&rsquo;ll be focusing on <a href="http://clojure.org/">Clojure</a> - address many of the concerns raised by <a href="http://homepages.inf.ed.ac.uk/wadler/">Wadler</a>.</p>
<p>Let us begin.</p>
<h3 id="pattern-matching">Pattern Matching</h3>
<p>Here Clojure, and most - all? - Lisps, are out of luck.</p>
<p>The example used in the paper is that of summing all integers in a list. First in Haskell:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">sum</span> <span style="color:#66d9ef">[]</span>   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#a6e22e">sum</span> x<span style="color:#66d9ef">:</span>xs <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> sum xs
</code></pre></div><p>Now in Clojure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#66d9ef">defn </span>sum [coll]
	(<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">empty?</span> coll)
		<span style="color:#ae81ff">0</span>
		(+ (first coll) (<span style="color:#a6e22e">sum</span> (rest coll)))))
</code></pre></div><p>The question here is this: Which snippet is easier to read/reason about? the Haskell code!</p>
<p>I must confess that I, too, miss pattern matching sometimes. However we can still improve our Clojure version to read nicer on the eyes by using <a href="http://www.haskell.org/haskellwiki/Haskell">destructuring</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#66d9ef">defn </span>sum [[first <span style="color:#f92672">&amp;</span> rest <span style="color:#e6db74">:as</span> coll]]
	(<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">empty?</span> coll)
		<span style="color:#ae81ff">0</span>
		(+ first (<span style="color:#a6e22e">sum</span> rest))))
</code></pre></div><p>And that&rsquo;s pretty much it. Without proper pattern matching, we can&rsquo;t get much better than that.</p>
<p>In addition to the Haskell snippet being easier to read, it&rsquo;s also easier to prove correct by structural induction, as demonstrated in Wadler&rsquo;s paper.</p>
<blockquote>
<p>Note: <a href="https://github.com/clojure/core.match">core.match</a> adds support to pattern matching in Clojure. At the time of this writing, it&rsquo;s considered &ldquo;alpha quality&rdquo;</p>
</blockquote>
<h3 id="data-structures">Data structures</h3>
<p>The paper continues to discuss exercise 2-27 from the <a href="http://mitpress.mit.edu/sicp/">SICP</a>, where the reader has to write code to represent a binary mobile, which consists of a left and right branch with each branch being a rod of certain length, from which hangs either a weight or another binary mobile.</p>
<p>Translating the Scheme example to Clojure, such a structure is represented using lists, like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#66d9ef">defn </span>make-mobile [left right] 
	(list left right))
	
(<span style="color:#66d9ef">defn </span>make-branch [length structure]
	(list length structure))
</code></pre></div><p>Wadler then contrasts this with the equivalent Miranda code, translated below to Haskell, taking advantage of <a href="http://www.haskell.org/haskellwiki/Algebraic_data_type">algebraic data types</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Structure</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Weight</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Mobile</span> <span style="color:#66d9ef">Branch</span> <span style="color:#66d9ef">Branch</span>
<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Branch</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Branch</span> <span style="color:#66d9ef">Int</span> <span style="color:#66d9ef">Structure</span>
</code></pre></div><p>The first claim is that the Haskell/Miranda data type declaration makes it clearer what the data structure looks like, which is fair.</p>
<p>Also, the compiler can catch errors early on.</p>
<p>However, when writing idiomatic Clojure code, here&rsquo;s how I&rsquo;d actually create this structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#66d9ef">defn </span>make-mobile [left right] 
	{<span style="color:#e6db74">:left</span> left <span style="color:#e6db74">:right</span> right})
	
(<span style="color:#66d9ef">defn </span>make-branch [length structure]
	{<span style="color:#e6db74">:length</span> length <span style="color:#e6db74">:structure</span> structure})
</code></pre></div><p>Granted, it&rsquo;s still not as clear and the compiler can&rsquo;t validate the shape of our data structure.</p>
<p>This is however cleaner than the previous version and drives home the point that Clojure isn&rsquo;t limited to lists, having literals for other data types such as the hash maps used in this example.</p>
<p>The second part of this claim is that through custom data types and pattern mathing, extracting values from those structures becomes simpler:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">totalWeight</span> (<span style="color:#66d9ef">Weight</span> w) <span style="color:#f92672">=</span> w
<span style="color:#a6e22e">totalWeight</span> (<span style="color:#66d9ef">Mobile</span> l r) <span style="color:#f92672">=</span> totalWeightBranch l <span style="color:#f92672">+</span> totalWeightBranch r

<span style="color:#a6e22e">totalWeightBranch</span>(<span style="color:#66d9ef">Branch</span> d s) <span style="color:#f92672">=</span> totalWeight s
</code></pre></div><p>Once again Clojure can improve things by taking advantage of its builtin data structures and destructuring:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#66d9ef">defn </span>total-weight [{<span style="color:#e6db74">:keys</span> [left right] <span style="color:#e6db74">:as</span> structure}]
	(<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">number?</span> structure)
		structure
		(+ (<span style="color:#a6e22e">total-weight-branch</span> left)
		   (<span style="color:#a6e22e">total-weight-branch</span> right))))
		   
(<span style="color:#66d9ef">defn </span>total-weight-branch [{structure <span style="color:#e6db74">:structure</span>}]
	(<span style="color:#a6e22e">total-weight</span> structure))		   
</code></pre></div><p>For a language with no pattern matching nor algebraic data types, this snippet is clear, concise and elegant - and a real improvement
over the Scheme version discussed in the paper - which was essentially handicapped by the use of lists to simulate &lsquo;structs&rsquo;.</p>
<p>As far as Clojure goes, this claim ends here: the next point in the paper, about changing from using <code>list</code> to using <code>cons</code>, is rendered moot since
we&rsquo;re using hash maps to represent our mobiles.</p>
<h3 id="lisp-lists-are-not-self-escaping">Lisp lists are not self-escaping</h3>
<p>Creating lists in Clojure goes like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(list (list <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>) nil) <span style="color:#75715e">;; ((1 2) nil)</span>

<span style="color:#f92672">&#39;</span>((<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>) nil) <span style="color:#75715e">;; ((1 2) nil)</span>
</code></pre></div><p>Both statements above are equivalent, with the second one being clearly more concise.</p>
<p>The claim here is that the fact that you need to either use the <code>list</code> function or quote the form is cumbersome and can be confusing to beginners.</p>
<p>Clojure solves this by providing literals to another data structure - vectors:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">[[<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>] nil]
</code></pre></div><p>Simple and concise - in fact, in idiomatic Clojure code, you&rsquo;ll rarely see quoted lists where a vector will do.</p>
<p>This is possible because both lists and vectors conform to a higher level abstraction called a <a href="http://clojure.org/sequences#Sequences-The%20Seq%20library-Seq%20in,%20Seq%20out">Seq</a>, in terms of which most list
operations are defined.</p>
<p>This eliminates the two following points mentioned in the paper as it allows a beginner to defer his/her understanding of quoted forms
to more advanced lessons/usages.</p>
<h3 id="programs-that-manipulate-programs---the-interpreter-example">Programs that Manipulate Programs - the interpreter example</h3>
<p>Here Wadler shows a simple grammar for an interpreter in both Miranda and Scheme.</p>
<p>He claims that since Haskell/Miranda have free data types, representing such grammar becomes simpler:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Term</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Var</span> [<span style="color:#66d9ef">Char</span>]
			<span style="color:#f92672">|</span> <span style="color:#66d9ef">Lambda</span> <span style="color:#66d9ef">Var</span> <span style="color:#66d9ef">Term</span>
			<span style="color:#f92672">|</span> <span style="color:#66d9ef">Apply</span> <span style="color:#66d9ef">Term</span> <span style="color:#66d9ef">Term</span>
			<span style="color:#f92672">|</span> <span style="color:#66d9ef">Closure</span> <span style="color:#66d9ef">Env</span> <span style="color:#66d9ef">Var</span> <span style="color:#66d9ef">Term</span>
<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Env</span> <span style="color:#f92672">=</span> [(<span style="color:#66d9ef">Var</span>, <span style="color:#66d9ef">Term</span>)] 
<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Var</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">Char</span>]
</code></pre></div><p>This is true in that one can easily scan the snippet above and deduce quickly what <code>Term</code> looks like.</p>
<p>Then, by using pattern matching, <code>eval</code> could be implemented like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">eval</span> e (<span style="color:#66d9ef">Var</span> v) <span style="color:#f92672">=</span> lookup e v
<span style="color:#a6e22e">eval</span> e (<span style="color:#66d9ef">Lambda</span> v t) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Closure</span> e v t
<span style="color:#a6e22e">eval</span> e (<span style="color:#66d9ef">Apply</span> t0 t1) <span style="color:#f92672">=</span> apply (eval e t0) (eval e t1)

<span style="color:#f92672">...</span>
</code></pre></div><p>I do believe this makes Haskell an excellent choice for writing interpreters and compilers.</p>
<p>However, the flip side is that entering such terms in Haskell is cumbersome. Consider the term below:</p>
<blockquote>
<p>(λx.(x x)) (λx.(x x))</p>
</blockquote>
<p>This is how to represent this term using the grammar defined above:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">(apply (<span style="color:#66d9ef">Lambda</span> <span style="color:#e6db74">&#34;x&#34;</span> (apply (<span style="color:#66d9ef">Var</span> <span style="color:#e6db74">&#34;x&#34;</span>) (<span style="color:#66d9ef">Var</span> <span style="color:#e6db74">&#34;x&#34;</span>))) 
       (<span style="color:#66d9ef">Lambda</span> <span style="color:#e6db74">&#34;x&#34;</span> (apply (<span style="color:#66d9ef">Var</span> <span style="color:#e6db74">&#34;x&#34;</span>) (<span style="color:#66d9ef">Var</span> <span style="color:#e6db74">&#34;x&#34;</span>))))
</code></pre></div><p>The strength in Lisp lies elsewhere. Since we have quoted forms, entering a similar term is a lot less verbose and closer to its intended representation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure"><span style="color:#f92672">&#39;</span>((<span style="color:#a6e22e">lambda</span> [x] (<span style="color:#a6e22e">x</span> x)) (<span style="color:#a6e22e">lambda</span> [x] (<span style="color:#a6e22e">x</span> x)))
</code></pre></div><p>This is, of course, at the expense of making <code>eval</code> a more complicated function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#66d9ef">defn </span>eval [e t] 
  (cond (<span style="color:#a6e22e">variable?</span> t)
        (<span style="color:#a6e22e">lookup</span> e (<span style="color:#a6e22e">variable-name</span> t))
        (<span style="color:#a6e22e">lambda?</span> t)
        (<span style="color:#a6e22e">make-closure</span> e (<span style="color:#a6e22e">lambda-var</span> t) (<span style="color:#a6e22e">lambda-body</span> t))
        (<span style="color:#a6e22e">apply?</span> t)
        (apply (eval e (<span style="color:#a6e22e">apply-operator</span> t))
               (eval e (<span style="color:#a6e22e">apply-operand</span> t)))))
               
...
</code></pre></div><p>The paper leaves out an important advantage of Lisps though:</p>
<p>Because we can write code for our made up language directly in its (almost)abstract syntax tree form, Lisps are the ideal choice when writing <a href="http://martinfowler.com/bliki/InternalDslStyle.html">Internal Domain Specific Languages</a>.</p>
<h3 id="lazy-evaluation">Lazy Evaluation</h3>
<h4 id="lists">Lists</h4>
<p>Haskell and Miranda are lazy languages and that yields a lot of power. This claim is more specific to the use of lazy lists - or sequences, streams - and starts off with a snippet that calculates the sum of squares of all odd numbers from 1 up to 100:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">sum</span> [ i<span style="color:#f92672">*</span>i <span style="color:#f92672">|</span> i <span style="color:#f92672">&lt;-</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">100</span>], odd i ]
</code></pre></div><p>What follows in the paper is a not-so-clear snippet of equivalent functionality using Scheme streams.</p>
<p>Clojure features lazy sequences and list comprehensions, making the above Haskell example trivial to write:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a6e22e">sum</span> (for [i (range <span style="color:#ae81ff">100</span>) <span style="color:#e6db74">:when</span> (<span style="color:#a6e22e">odd?</span> i)] (* i i)))
</code></pre></div><p>If you&rsquo;re following at home with the original paper you&rsquo;ll see this is more readable and elegant than the equivalent Scheme example.</p>
<p>Another - also idiomatic - way to write the same expression is by using a combination of map/filter:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a6e22e">sum</span> (map <span style="color:#f92672">#</span>(* % %) (filter odd? (range <span style="color:#ae81ff">100</span>))))
</code></pre></div><p>Deciding which one is clearer is left as an exercise to the reader.</p>
<h4 id="special-forms-and-lazy-evaluation">Special forms and lazy evaluation</h4>
<p>In this section, Wadler brings another example from SICP where the reader wishes to implement his/her own <code>if</code> form.</p>
<p>As we know, in order to implement our own version of <code>if</code>, we need to use macros. That is because in Lisps arguments to functions are eagerly evaluated.</p>
<p>One might implement it like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#66d9ef">defmacro </span>my-if [pred then else]
  <span style="color:#f92672">`</span>(cond <span style="color:#f92672">~</span>pred <span style="color:#f92672">~</span>then
  		<span style="color:#e6db74">:else</span> <span style="color:#f92672">~</span>else))
</code></pre></div><p>In Lazy languages, such as Haskell and Miranda, this problem doesn&rsquo;t occur allowing such functions to be defined without the need for special and/or quoted forms:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">myIf</span> <span style="color:#66d9ef">True</span>  t e <span style="color:#f92672">=</span> t
<span style="color:#a6e22e">myIf</span> <span style="color:#66d9ef">False</span> t e <span style="color:#f92672">=</span> e
</code></pre></div><p>However this completely dismisses the power of macros which allow you to extend the language in ways no other language allows - as is extensively demonstrated in books such as <a href="http://amzn.to/14mrrbk">On Lisp</a> and <a href="http://amzn.to/WKpMZA">Let Over Lambda</a>.</p>
<p>As <a href="http://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.">Guy Steele</a> once put it:  <em>&quot;[…] If you give someone Lisp, he has any language he pleases&rdquo;</em></p>
<h3 id="conclusion">Conclusion</h3>
<p>Hopefully this post doesn&rsquo;t come off as trying to invalidate Wadler&rsquo;s paper - that is not my intention.</p>
<p>While I do think a few of the points discussed are only applicable to the domain in which his paper was written - teaching - they are still valid and worth understanding.</p>
<p>I do however expect to have given you a different perspective on it, showing the strengths of modern Lisps such as Clojure and how it approaches these issues - such as by using its rich set of data structures, literals and techniques such as destructuring.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "leonardoborges" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://leonardoborges.com/" >
    &copy;  Leonardo Borges 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
